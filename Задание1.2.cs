using System;

namespace Zadanie1._2

{
    class Example
    {
        public const int C = 1;
        public readonly int r = 3;


        public void Method()
        {
            // r = 4; -ошибка, так как переменная, доступная только для чтения
            //может быть изменена только в конструктуре;
        }

        public int a;
        public static int b;

        public void SetB(int b)
        {
            //this.b = b; - ошибка, так как this - ссылка на объект класса. Для вызова статических полей объекты класса не нужны
            Example.b = b;
            //однако, для обращение к нестатической переменной нужно указывать ссылку на объект, т.е. для обращения к полю "a", нужно
            this.a = b;
        }
        public void PrintB()
        {
            Console.WriteLine(b);
        }

        public static readonly int _a; //Сам по себе тип readonly является неявно статическим. Однако, мы можем объявить его явно статическим

        public Example()
        {
            // C = 2; - ошибка, так как константа не может быть изменена 
            r = 4; //изменение переменной типа readonly в конструктуре возможно
            //_a = 5; однако тип static readonly изменить в конструкторе мы не можем
        }
        static Example()
        {
            _a = 5;// чтобы изменить тип static readonly нужен статический метод
        }


    }

    class Program
    {
        static void Main(string[] args)
        {
            int T = Example.C; // Присваивание переменной T значение константы

            // Example.C=3; - ошибка, так как константа не может быть изменена

            Example e = new Example();
            //e.r = 4; - ошибка, т.к. переменная типа readonly может быть изменена только в конструкторе;
            int v = e.r; // присваивание переменной v значение переменной r;

            //Чтобы наглядно показать поведение статических полей, следует рассматривать их на контрасте с обычными полями
            Example ex1 = new Example();
            ex1.a = 5; //чтобы обратиться к нестатическому методу класса, нужно создать экземпляр класса. Для
            //ex1.b = 6; выдаст ошибку, так как к статическим полям класса нельзя обращаться через экземпляр 
            // т.к. на статические поля класса выделяется отдеальное место в памяти;
            //чтобы обратиться к статическому полю класса, нужно обращаться напрямую через объект класса(пример ниже)
            Example.b = 6;
            Example ex2 = new Example();
            ex2.a = 6; //Для каждого экземпляра класса создается свой экземпляр поля, в котором можно храниться разные значения. 

            ex1.SetB(10);
            ex2.PrintB(); //В данном случае, если бы переменная b была не static, то все действия над экзмепляром ex1 никак не отобразились бы на 
            // екземпляре ex2. Но так как под статические поля выделяется общая память ошибки не будет и в конечном итоге в консоль выведится значение b = 10;
        } 
    }

   
